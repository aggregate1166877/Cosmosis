Move cam[0] logic into ship loader.
 - Ship orientation cam.
 - Initial cam.
 - Bridge cam.
 - Ship outside cam.

Make the ship loader load gltf lights.

Cam controllers currently have the option to be notified when they are loaded.
They do however not have a direct mechanism to be notified if a different
controller is being loaded, making checking verbose copy-pasta. Implement
something in core to facilitate this.

Put first load mode in index.js.

Make ship movable with physics using keyboard controls.

Test bridge cam attach in both local and world transform.

Test switching between hyperdrive and regular.

Implement world position reset when switching to/form hyperdrive.

Implement physics in a universally easy to use way.

Implement a ramp based spedometer and make sure distances measured with m/s check out.

Add core controls top right below FPS:
 - F1: show all controls.
 - Middle click: or Num5 to lock mouse.
 - J: jump into (and out of) hyperspace.
 - WASD and EF: move ship.
 - F2: show / hide this text.

-- Set up a spacecube field and make the ship travel through it (just via brute
force, no need for physics right now). Then ensure the player stays on the ship
and doesn't get left behind, in all modes. Maybe give to option to let one
detach from ship in free cam mode.

Implement full warp drive controls.

Implement an analog logarithmic speedometer (or at least a relative one).
Show all speeds underneath, but make the font smallers as the numbers grow.
Move position and rotation to left bottom.

Implement dynamic gravity.
Address the walking through wall problem.
Consider implementing invisible floors to make walking smoother.

Create indicator that shows "Press [] to interact." or "[] Interact."
Make the border be in the direction of the switch highlighted.
Maybe place an actual arrow next the border closer the the interactable, but
this last one is optional.

100km/h -> 3000c -> 3 billion c
[messes up past about 50% galaxy width, but it's consistent and can likely be worked around]

Some technical problems to consider:
Moving at 3000c causes the camera to jump around *slightly*. \[Note that this was
*after* render order optimisations which fixed glitches showing at 100km/h
already.] This get worse until the game is eventually unplayable. Some tests I
did suggest that the problem gets far worse as distance to the world coords
0,0,0 goes into the multimillions. A solution was found: don't move the space
ship at all - move the entire universe in opposite direction instead. This
completely solves not only the jumpiness, but means the skybox is now stable
too. The results were good even at 3 billion times the speed of
light (I stopped there because we'll never need nearly that much). The
glitchiness vanished, but there is one last problem. At exactly 2 specific
distances from 0,0,0, the camera first jumps about around 3 meters forward
from where is should be, and then jumps 3 meters back from where it should be.
I don't have exact values, happens at around 75,000ly and 150,000ly. Note
however it isn't glitchy and stays stable despite the bad cam positions,
meaning we can hopefully code around it when the time comes.
At the time of writing, I have no clue if you can make physics system
(cannon.js) account for this. Even if you could, it's likely unnecessary.
Instead, I propose a solution where the player movement vs universe movement
is done dynamically based on certain conditions, which disables physics as needed.
* [Ship movement] Player can accelerate infinitely using normal engines, but make
this infeasible. Basically, accelerate about as fast as the Parker Solar Probe,
which would take about 3.5 years to travel 1AU. Also limit ship speed to 400m/s
by default using safety mechanisms, but allow the player to unlock acceleration
via ship hack. Maybe have the ship automatically engage hyperdrive past a
certain speed (if equipped).
* [Universe movement] To travel as reasonable speeds, jump into hyperdrive.
When doing this, disable all physics. This allows us to transform the world
instead of the ship. We'll need to ensure the entire game is compatible with
the change in ref calculations.
* Hyperspace (IID) of course just instantly teleports you, so it does what
hyperdrive does.
* When the player exits hyper\[*], parent it to a new group and transform it to
world 0,0,0. Then transform the universe such that the player is the center of
the universe just like my ex. Reactivate physics at the new center of
universe.
* Profit.

Detail a standard for mesh creation. Maybe with a json file that describes how
the mesh is the be loaded, example:
{
  "main": { "label": "hull" },
  "captainSeat": { "label": "cube.002" },
  "navMonitor": ...
  "combatMonitor": ...
  "statusMonitor": ...
  "shipMonitor": ...
  "generic_seats": [
    { "label": "rear_observation_seat"  }
  ],
  "doors": [
    { "label": "loading_bay", "switch": "loading_bay_switch" }
  ]
}
Check if GLTF supports collections. If so place internal ship lights into those
collections, like "cockpitLights" etc and see if other lights like individual
crew quarters can be tagged somehow. This would allow for highly dynamic ship
function with zero additional coding needed for new ships. Maybe tagged via
specially named materials (which 100% would fail in engines like godot, because
material names are global and therefore need to be unique).

Implement mode switches correctly WRT ship controls, then follow that with menu
controls.

Implement switching between body cam and free cam. Make body cam the default.

either of these first: [
    - Implement ship modular power systems.
    - Create in-ship computer interface:
        * Navigation
        * Combat
        * Status
        * Ship
]

create weapon modules.

implement firing groups.

create some environments:
    - saturn, to scale. hexagon storm demo.
    - something akin to ME citadel, to scale, with some landing spots.
    - implement orbital station, orbiting star.

implement hyper relays (star gate).

implement hyper drive.

implement multiplayer.

implement ai.

make procedural universe.

make galaxy map.



--------------------------------------------------------------------

Technical debt
==============

ammo.js was copied from node_modules to hackedlibs to fix a crash. See its
readme for more details.

--------------------------------------------------------------------

Misc
==============

Find a good way to limit frame rate
-----------------------------------

The application's frame rate is currently controlled by
`node_modules/react-three-fiber/web.js` -> renderLoop()

To limit the frame rate, this line:
`if (repeat !== 0) return requestAnimationFrame(renderLoop);else {`

can be replaced with this this block:
```js
if (repeat !== 0) {
    // return requestAnimationFrame(renderLoop);
    return setTimeout( function() {
      requestAnimationFrame(renderLoop);
    }, 1000 / 30 );
  }
  else {
```

which limits the frame rate to 30fps in this case. The game HAS TO BE frame
rate independent. This is not optional. The problem is that, testing on lower
frame rates, is really difficult when the functionality is hidden away in a
module. Find a way to make this as simple as changing a parameter. Submit a PR
on the issue maybe?
