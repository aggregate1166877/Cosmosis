import * as THREE from 'three';
import CosmosisPlugin from '../../types/CosmosisPlugin';
import PluginCacheTracker from '../../../emitters/PluginCacheTracker';
import Core from '../Core';
import Player from '../Player';
import {
  SBA_LENGTH, ROT_W, ROT_X, ROT_Y, ROT_Z, BUFFER_TYPE, TYPE_POSITIONAL_DATA,
} from '../../../webWorkers/sharedBufferArrayConstants';
import MeshLoader from '../NodeOps/types/MeshLoader';
import { gameRuntime } from '../../gameRuntime';
import {
  extractAndPopulateVerts,
  extractVertsFromGeo,
} from '../../../local/mathUtils';

type PluginCompletion = PluginCacheTracker & {
  player: Player, core: Core,
};

class OffscreenGalaxyWorker extends Worker {
  private _pluginTracker!: PluginCacheTracker | PluginCompletion;
  private transferablePosition!: Float64Array;

  constructor() {
    // Note: offscreenGalaxy.js is generated by Webpack. The actual source file
    // is located at: app/webWorkers/offscreenGalaxy.ts
    super('./build/offscreenGalaxy.js', { type: 'module' });

    // const loader = new MeshLoader('milky_way', 'getStarCatalog', {
    const loader = new MeshLoader('milky_way', 'getStarCatalog', {
      ...MeshLoader.defaultNodeOpts,
      castShadow: false,
      receiveShadow: false,
    });
    loader.trackedMesh.getOnce((galaxy) => {
      gameRuntime.tracked.levelScene.getOnce((scene) => {
        const gltfScene: THREE.Scene = galaxy.gltf.scene;

        gltfScene.traverse((node) => {
          if (node.type !== 'LineSegments') {
            return;
          }

          // @ts-ignore
          const lineSegments: THREE.LineSegments = node;
          console.log({ lineSegments });

          const vertPositions = extractAndPopulateVerts(lineSegments.geometry);
          const { x: sx, y: sy, z: sz } = lineSegments.scale;

          const group = new THREE.Group();
          for (let i = 0, len = vertPositions.length; i < len; i++) {
            const v3: THREE.Vector3 = vertPositions[i];
            const geometry = new THREE.BoxGeometry(0.001 / sx, 0.001 / sy, 0.001 / sz);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            group.add(cube);
            cube.position.set(v3.x, v3.y, v3.z);
          }
          lineSegments.add(group);
        });

        scene.add(gltfScene);
      });
    });


    return;

    this.addEventListener('message', this.receiveMessage.bind(this));
    this._init();

    this.transferablePosition = new Float64Array(SBA_LENGTH);

    this._pluginTracker = new PluginCacheTracker([ 'core', 'player' ]);
    this._pluginTracker.onAllPluginsLoaded.getOnce(() => {
      this._pluginTracker.core.onAnimate.getEveryChange(() => {
        const cam: THREE.PerspectiveCamera = this._pluginTracker.player.camera;
        if (!cam) {
          return;
        }
        this.sendPositionalInfo(cam);
      });
    });
  }

  _init() {
    // @ts-ignore
    const canvas: HTMLCanvasElement = document.getElementById('galaxy-canvas');
    if (!canvas || !('transferControlToOffscreen' in canvas)) {
      // TODO: handle this better. Or not - we choose the NW.js version, and
      //  won't choose something that doesn't boot. Needs thought.
      console.error('[OffscreenGalaxyWorker] Error creating offscreen canvas.');
      return;
    }

    // TODO: on resize, post a message telling to change size.
    // @ts-ignore
    const offscreen = canvas.transferControlToOffscreen();
    this.postMessage({
      endpoint: 'init',
      drawingSurface: offscreen,
      width: window.innerWidth,
      height: window.innerHeight,
      pixelRatio: window.devicePixelRatio,
      path: '..',
    }, [ offscreen ]);
  }

  receiveMessage(message) {
    const data = message.data;
    if (data.buffer) {
      this.transferablePosition = data;
    }
    else {
      console.warn('[OffscreenGalaxyWorker] Posted message not understood.');
    }
  }

  sendPositionalInfo(camera: THREE.PerspectiveCamera) {
    const bufferArray = this.transferablePosition;

    if (!bufferArray.byteLength) {
      // Variable is currently locked by another thread and is not usable.
      return;
    }

    const quaternion = camera.quaternion;

    bufferArray[BUFFER_TYPE] = TYPE_POSITIONAL_DATA;
    bufferArray[ROT_X] = quaternion.x;
    bufferArray[ROT_Y] = quaternion.y;
    bufferArray[ROT_Z] = quaternion.z;
    bufferArray[ROT_W] = quaternion.w;

    this.postMessage(bufferArray, [ bufferArray.buffer ]);
  }
}

const offscreenGalaxyWorkerPlugin = new CosmosisPlugin('offscreenGalaxyWorker', OffscreenGalaxyWorker);

export {
  OffscreenGalaxyWorker,
  offscreenGalaxyWorkerPlugin,
}
